#+TITLE: FEDVR.jl
#+AUTHOR: Stefanos Carlström
#+EMAIL: stefanos.carlstrom@gmail.com

[[https://travis-ci.org/jagot/FEDVR.jl][https://travis-ci.org/jagot/FEDVR.jl.svg?branch=master]]
#+HTML: <a href="https://ci.appveyor.com/project/jagot/fedvr-jl"><img src="https://ci.appveyor.com/api/projects/status/nxei8dj3jp11vb2d?svg=true" alt="Sorry, your browser does not support SVG."/></a>

[[https://coveralls.io/github/jagot/FEDVR.jl?branch=master][https://coveralls.io/repos/github/jagot/FEDVR.jl/badge.svg?branch=master]]
[[https://codecov.io/gh/jagot/FEDVR.jl][https://codecov.io/gh/jagot/FEDVR.jl/branch/master/graph/badge.svg]]

#+PROPERTY: header-args:julia :session *julia-FEDVR*

This is a Julia package for the Finite-Element Discrete Variable
Representation method, used in the solution of partial differential
equations. The main purpose for the package is for numerical solution
of the [[https://en.wikipedia.org/wiki/Schrödinger_equation][Time-Dependent Schrödinger Equation]] ([i∂ₜ-Ĥ]|ψ⟩ = 0), however,
its usefulness is not limited to this equation.

* Usage
** Grid setup
   #+BEGIN_SRC julia :exports code
     using FEDVR
   #+END_SRC

   #+RESULTS:
   : nothing

   #+BEGIN_SRC julia :exports none
     using Plots
     pyplot()
     using LaTeXStrings
   #+END_SRC

   #+RESULTS:
   : nothing

   We set up the basis for the calculations like so:
   #+BEGIN_SRC julia :exports both :results verbatim
     basis = FEDVR.Basis(linspace(0,1,11),10)
   #+END_SRC

   #+RESULTS:
   : FEDVR Basis(FEDVR Grid with 10 elements of order 10 [dirichlet0,dirichlet0])
   By default, Dirichlet0 boundary conditions at both boundaries are
   assumed (by passing any other symbol than =:dirichlet0=, Dirichlet1
   boundary conditions are applied; Neumann boundary conditions not yet
   supported).

   We can then plot the grid point locations:
   #+BEGIN_SRC julia :exports code
     plot(basis.grid)
   #+END_SRC

   #+RESULTS:

   #+BEGIN_SRC julia :exports results :results file
     savefig("figures/grid.svg")
     "figures/grid.svg"
   #+END_SRC

   #+RESULTS:
   [[file:figures/grid.svg]]

   as well as the basis functions:
   #+BEGIN_SRC julia :exports code
     plot(basis)
   #+END_SRC

   #+RESULTS:
   : Plot{Plots.PyPlotBackend() n=91}

   #+BEGIN_SRC julia :exports results :results file
     savefig("figures/basis.svg")
     "figures/basis.svg"
   #+END_SRC

   #+RESULTS:
   [[file:figures/basis.svg]]

** Expansion of scalar functions
   A scalar function can be expanded by
   #+BEGIN_SRC julia :exports code
     f = x -> x*(x-1)^2
     ϕ = project(f, basis)
   #+END_SRC

   #+RESULTS:
   |                      0 |
   |   0.000325830025125707 |
   |  0.0013490760116050549 |
   |  0.0029918271272773764 |
   |   0.004904544516409527 |
   |  0.0066126466713751645 |
   |   0.007658607990372382 |
   |  0.0076856822425758016 |
   |   0.006403757547967093 |
   |  0.0038183766184073575 |
   |   0.006817637559265904 |
   |   0.009431280098888922 |
   |   0.011637399050586843 |
   |   0.013361003815921039 |
   |   0.014349965883489448 |
   |   0.014340608107144605 |
   |   0.013104342304539269 |
   |   0.010343119442593569 |
   |   0.006033977866125207 |
   |    0.01055334944274316 |
   |   0.013991227714725872 |
   |    0.01636369662541401 |
   |   0.017786858771384185 |
   |   0.018183587825801942 |
   |   0.017449846547176396 |
   |   0.015470783075994709 |
   |   0.011976817270000696 |
   |   0.006929646455628164 |
   |    0.01202281339019125 |
   |   0.015665158448982523 |
   |   0.017895755596135272 |
   |      0.018949945022849 |
   |   0.018881348138362668 |
   |    0.01771135905484415 |
   |   0.015421244146808755 |
   |   0.011794698744822262 |
   |   0.006788225099390855 |
   |   0.011715877116243934 |
   |   0.015089311891525464 |
   |    0.01695861170712702 |
   |   0.017618098210365474 |
   |    0.01721108246122162 |
   |   0.015850181374524257 |
   |   0.013591965106847974 |
   |   0.010286611581692022 |
   |   0.005892556509887896 |
   |   0.010122388335534986 |
   |   0.012899927632221314 |
   |   0.014277300702765644 |
   |   0.014559153973983633 |
   |   0.013940626434428829 |
   |   0.012591349250593105 |
   |      0.010619185545979 |
   |    0.00794240349524375 |
   |   0.004525483399593905 |
   |   0.007732194762698184 |
   |   0.009733245260936678 |
   |   0.010576858327427555 |
   |   0.010540947953753493 |
   |    0.00983781569803431 |
   |     0.0086598984274271 |
   |   0.007139145054068436 |
   |   0.005251922200111207 |
   |   0.002969848480983501 |
   |   0.005035144112367283 |
   |   0.006225504367538161 |
   |   0.006582320325489128 |
   |  0.0063313157897250645 |
   |   0.005670485892088076 |
   |   0.004780864649402632 |
   |   0.003788083220982885 |
   |  0.0027050154109281737 |
   |  0.0015084944665313012 |
   |  0.0025210840991760543 |
   |   0.003012944541892365 |
   |  0.0030187224413267557 |
   |  0.0026980931219483654 |
   |  0.0022064726566401282 |
   |   0.001679283660896085 |
   |  0.0012022396365889464 |
   |  0.0007915308423284082 |
   | 0.00042426406871192833 |
   |  0.0006798624377582713 |
   |  0.0007318053738659035 |
   |  0.0006111004193168488 |
   | 0.00040911559047340345 |
   | 0.00021361163174049875 |
   |   8019120628386123e-20 |
   |   1785389075323825e-20 |
   |  13162089456893346e-22 |
   |                      0 |

   #+BEGIN_SRC julia :exports results :results file
     Xp = locs(basis.grid)
     x = linspace(minimum(Xp),maximum(Xp),1001)
     χ = evaluate(basis, x)

     experror = clamp.(abs.(f.(x)-χ*ϕ), 1e-20, Inf)

     p = plot(x, f.(x), label=L"f(x)")
     plot!(p, x, χ*ϕ, linestyle=:dash, label="Reconstruction")
     plot!(p, Xp, ϕ, markershape=:circle, label="Expansion coefficients")

     pe = plot(x, experror, yscale=:log10, label="Reconstruction error")

     plot(p,pe,layout=(2,1))
     savefig("figures/expansion.svg")
     "figures/expansion.svg"
   #+END_SRC

   #+RESULTS:
   [[file:figures/expansion.svg]]

   Note that the function expanded has to vanish at the boundaries of
   the grid, since =:dirichlet0= was chosen above. For non-vanishing
   functions, pass =:dirichlet1= to the =Basis= constructor.

** Kinetic operator
   The 1D kinetic operator is given by T̂ = -∂ₓ²/2, and can be
   retrieved by
   #+BEGIN_SRC julia :exports both :results verbatim
     T = kinop(basis)
   #+END_SRC

   #+RESULTS:
   : BlockMaps.BlockMap{Float64}(91, 91, BlockMaps.Block{Float64}[10x10 Float64 block at (1,1), 10x10 Float64 block at (10,10), 10x10 Float64 block at (19,19), 10x10 Float64 block at (28,28), 10x10 Float64 block at (37,37), 10x10 Float64 block at (46,46), 10x10 Float64 block at (55,55), 10x10 Float64 block at (64,64), 10x10 Float64 block at (73,73), 10x10 Float64 block at (82,82)], false, false, false, true, 1.0e-8)
   which returns a [[https://github.com/jagot/BlockMaps.jl][BlockMap]], a [[https://github.com/Jutho/LinearMaps.jl][LinearMap]] that is specialized for
   structured matrices consisting of blocks such as those arising from
   a FEDVR treatment.

   Its eigenstates (also known as the eigenstates of a
   particle-in-a-box) can be computed using [[https://docs.julialang.org/en/stable/stdlib/linalg/#Base.LinAlg.eigs-Tuple{Any}][Julia's builtin sparse
   diagonalization routine]]:
   #+BEGIN_SRC julia :exports code :results verbatim
     λ,ϕ = eigs(T,which=:SR)
   #+END_SRC

   #+RESULTS:

   #+BEGIN_SRC julia :exports results :results file
     p = plot(layout=(2,1), link=:both, leg=false)
     plot!(p[1],Xp,real.(ϕ),
           marker=:circle,
           ylabel=L"\Re\{\mathbf{c}\}",
           xformatter=_->"")
     plot!(p[2], x,abs2.(χ*ϕ),
           xlabel=L"x",
           ylabel=L"|\phi_n(x)|^2")

     savefig("figures/eigenstates.svg")
     "figures/eigenstates.svg"
   #+END_SRC

   #+RESULTS:
   [[file:figures/eigenstates.svg]]

   If we plot the eigenvalues, we see the typical quadratic behaviour
   initially, but due to the division into finite elements, a series
   of steps occurs towards higher energies.
   #+BEGIN_SRC julia :exports results :results file
     λ = eigs(T,which=:SR,nev=100)[1];
     p = plot(layout=2, leg=false, xlabel="Eigenvalue #")
     plot!(p[1], real.(λ[1:45]))
     plot!(p[2], real.(λ))
     savefig("figures/eigenvalues.svg")
     "figures/eigenvalues.svg"
   #+END_SRC

   #+RESULTS:
   [[file:figures/eigenvalues.svg]]

* Wishes
  - Efficiently calculate matrix elements for
    - Local operators
    - Derivative operators
    - Two-body operators
  - Allow different polynomial orders n in different finite elements
  - Helper routines for different types of grids
    - Cartesian Nd grids
    - Spherical coordinates
      - Radial grid
      - Angular? [c.f. [[Schneider2016]]]
  - Tensor product bases (multi-body problems)
  - Laplacian operators
  - Exterior Complex Scaling [c.f. [[Rescigno2000]]]
  - Support for different quadratures [c.f. [[Baye2015]]]

* References
  1) <<Rescigno2000>>Rescigno, T. N., & McCurdy,
     C. W. (2000). Numerical grid methods for quantum-mechanical
     scattering problems. Physical Review A, 62(3), 032706.
     DOI: [[http://dx.doi.org/10.1103/physreva.62.032706][10.1103/physreva.62.032706]]

  2) <<McCurdy2001>>McCurdy, C. W., Horner, D. A., & Rescigno,
     T. N. (2001). Practical calculation of amplitudes for
     electron-impact ionization. Physical Review A, 63(2), 022711.
     DOI: [[http://dx.doi.org/10.1103/physreva.63.022711][10.1103/physreva.63.022711]]

  3) <<McCurdy2004>>McCurdy, C. W., Baertschy, M., & Rescigno,
     T. N. (2004). Solving the three-body coulomb breakup problem using
     exterior complex scaling. Journal of Physics B: Atomic, Molecular
     and Optical Physics, 37(17), 137–187.
     DOI: [[http://dx.doi.org/10.1088/0953-4075/37/17/r01][10.1088/0953-4075/37/17/r01]]

  4) <<Balzer2010>>Balzer, K., Bauch, S., & Bonitz, M. (2010). Finite
     elements and the discrete variable representation in
     nonequilibrium green’s function calculations. atomic and molecular
     models. Journal of Physics: Conference Series, 220(1), 012020.
     DOI: [[http://dx.doi.org/10.1088/1742-6596/220/1/012020][10.1088/1742-6596/220/1/012020]]

  5) <<Baye2015>>Baye, D. (2015). The Lagrange-mesh method. Physics
     Reports, 565, 1–107.  DOI: [[http://dx.doi.org/10.1016/j.physrep.2014.11.006][10.1016/j.physrep.2014.11.006]]

  6) <<Schneider2016>>Schneider, B. I., Guan, X., & Bartschat,
     K. (2016). Time propagation of partial differential equations
     using the Short Iterative Lanczos method and finite-element
     discrete variable representation. Advances in Quantum Chemistry, 72, 95–127.
     DOI: [[http://dx.doi.org/10.1016/bs.aiq.2015.12.002][10.1016/bs.aiq.2015.12.002]]
